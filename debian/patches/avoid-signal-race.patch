From: Arthur de Jong <arthur@arthurdejong.org>
Subject: Avoid signal race condition on start-up

This only restores the signal mask after signal handlers are in place
and the daemon has completely daemonised to avoid a race condition in
the start-up phase of nslcd where a signal could be sent to nslcd
causing it to quit or fail to write information to the parent process.

Origin: upstream, http://arthurdejong.org/git/nss-pam-ldapd/commit/?id=530cc24c83dd5d2d347acb40d64c3ae06a43a293
Bug-Debian: http://bugs.debian.org/759544

--- a/nslcd/daemonize.c
+++ b/nslcd/daemonize.c
@@ -89,7 +89,7 @@ static int read_response(int fd, char *b
   return r;
 }
 
-/* ihe process calling daemonize_daemon() will end up here on success */
+/* The parent process calling daemonize_daemon() will end up here on success */
 static int wait_for_response(int fd)
 {
   int i, l, rc;
--- a/nslcd/nslcd.c
+++ b/nslcd/nslcd.c
@@ -838,8 +838,7 @@ int main(int argc, char *argv[])
       exit(EXIT_FAILURE);
     }
   }
-  pthread_sigmask(SIG_SETMASK, &oldmask, NULL);
-  /* install signalhandlers for some signals */
+  /* install signal handlers for some signals */
   install_sighandler(SIGHUP, sig_handler);
   install_sighandler(SIGINT, sig_handler);
   install_sighandler(SIGQUIT, sig_handler);
@@ -850,6 +849,8 @@ int main(int argc, char *argv[])
   install_sighandler(SIGUSR2, SIG_IGN);
   /* signal the starting process to exit because we can provide services now */
   daemonize_ready(EXIT_SUCCESS, NULL);
+  /* enable receiving of signals */
+  pthread_sigmask(SIG_SETMASK, &oldmask, NULL);
   /* wait until we received a signal */
   while ((nslcd_receivedsignal == 0) || (nslcd_receivedsignal == SIGUSR1))
   {
